Complex Networks Notes

Notation:
sum(i,j,k,sum_expr) is sum from j to k with index i over sum_expr
[A^n] is matrix exponentiation: A to the nth power
A^T is matrix transpose of A



2018-08-28:
A graph G = (V,E) where V:nodes, E:edges,|V|=n,|E| = m

Adjacency matrix:
A:nxn
A_ij = {1 if there exists (j,i) e E
       {0 otherwise
If G is undirected, A_ij = A_ji foreach i,j
Degree of node i is # of edges incident on i
For undirected network/graph, degree of network is:
    -total count of 1s in adjacency matrix:
        sum(i,1,n,sum(i,1,n,A_ij))
density: c = (1/n)sum(1,n,A_i) = (2m/n)
Dense networks: easier to find paths through network but comm btween nodes could interfere more easily
Sparse networks: less contention but finding paths is slower
Find max number of nodes that are directly connected => vertex cover
Find max density (max num edges) => n choose 2 (pick any node, it has n-1 neighbors. Pick another, it has n-2, and so on for all nodes)

Walk: more general than a path
    a series of nodes v_1, v_2, ... , v_i where there exists an edge between v_i,v_i+1 for each i=1...n-1
How many walks of length n are in graph G?
    How many walks of length 2?
        sum(p,1,n,A_ip*A_pj) for each i,j = [A^2]_ij
    How many walks of length 3?
        sum(p,1,n,sum(q,1,n,A_ip*A_pq*A_qj)) i,j = [A^3]_ij
    How many walks of length r?
        [A^r]_ij
    How many cycles of length r that start and end on i
        [A^r]_ii
Tress:
    For any two nodes, there's only one path between
    It's possible to have n-1 edges but fail to have a tree
    Trees are fragile for use with routing: imagine removing one edge from the root to a subtree - that whole subtree is inaccessible!
    However, they are also efficient since there's only one path for each pair of nodes
        Can mitigate the fragility by having nodes remember connections to "siblings"

Directed Networks:
Edges have direction, adjacency matrix is no longer necessarily symmetric
    ex. If our nodes are papers and edges citations
    Cocitation matrix:
        For papers i,j,k:
        i<------k------->j
            c_ij = sum(1,n,k,A_ik*A_jk)
            (Cocitation matrix) C = c_ij foreach(i,j=1...n) = AA^T
    Bibliographic Coupling:
        For papers i,j,k:
        i------->k<-------j
        b_ij = sum(k,1,n,A_ki*A_kj)
        (Bibliographic coupling matrix) B = b_ij foreach(i,j=1...n)
For next time: directed acyclic graphs (DAGs)

2018-08-30:
DAGs
G = (V,E)
Reordering:
V = {v_1,v_2,...} -> v_1',v_2',v_3',...
such that (v_i',v_j') element of E for i<j

DFS: depth-first search
Each node has these atributes:
    -V.pi: parent of V
    -V.visited: been visited or not?
    Extra properties (in addition to the standard DFS things above):
    -V.start: start time of visit of node V
    -V.end: end time of visit of node V
Algorithm:

DFS(G):
    for v in V:
        v.pi = nil
        v.visited = false
        v.start = v.end = {}
    t=0
    for v in V where v.visited==false:
        DFS_VISIT(G,v)
    return nodes (optionally order by v.end desc)
    
DFS_VISIT(G,v):
    t++
    v.start = t
    v.visited = true
    for q where isAdjacent(q,v):
        if q.visited == false:
            q.pi = v
            DFS_VISIT(G,q)
    t++
    v.end = t
            
DFS is O(|V|+|E|) and the sort is at best O(|V|log|V|), so overall complexity depends on whether the graph is dense or sparse (|E| can be O(|V|^2)

Strongly-connected components:
G=(V,E) a directed graph
C a maximal (NOT THE SAME AS MAXIMUM SET) subset of V, foreach v,q elements of C
There is a path v -> q (and q -> v)
In undirected graphs, all connected components are strongly connected

Transpose (of a graph G):
    G^T =(V,E^T)
    E^T = {(v,q) if (q,v) in E}

Algorithm to find strongly-connected components:
SCC(G):
    DFS(G)
    Calculate G^T
    DFS(G^T) picking starting nodes in order by end times set in previous step
    return DFS trees
The set of DFS trees returned is also the set of strongly connected components!

2018-09-04:
Shortest path:
    G=(V,E), v_1,v_2 in V  v_1,v_2 in E w(v_1,v_2) in IR+
    w(v_1,v_2) in IR+
    Optimality principle:
    |-----P------|
    v-----Z------q
      p_1    p_2
      
      w(P) = delta(v,q)
      need to look up proof - proceeds by contradiction
      
Shortest path tree:
    foreach e in E, w(e) = c (all weights are constant c)
    Just do BFS. Each level is another multiple of c (c,2c,3c...)
    ******Shortest-path tree != minimum spanning tree******
    Djikstra's can do this too
    
Shortest-path: Floyd-Warshall
    W:n x n, n = |V|)
    switch(W[i,j]){
        case i=j: 0
        case w(i,j): (v_i,v_j) in E
        else: infinity
    }
    Intermediate Vertex: every node except source and destination
    path P = (v_1,v_2,...,v_k-1,v_k)
    Vertices are numbered 1,2,3,...n
    Consider a subset of the vertices {1,...,k}. Let P be the shortest path between two nodes i,j using only the nodes in {1,...,k} as intermediate nodes
    Two cases: does k appear as an intermediate vertex in P?
        if no: in P->all intermediate vertices are in {1,...,k-1}
                    ->the shortest path using {1,...,k-1} as intermediate nodes is also the shortest path using {1,...,k}
        if yes: k is an intermediate node in P:
            i----k-----j
              P_1  P_2
              P_1,P_2 are shortest paths
               k cannot be in P_1,P_2 or they wouldn't be shortest paths otherwise
               intermediate nodes between i,j must be in {1,...,k-1}
               
    Let d(i,j,k) means "shortest-path weight between i and j using nodes {1,...,k-1}
    Base case:k=0
        d(i,j,0) = W[i,j]
    Inductive case:
        d(i,j,k) = min( d(i,j,k-1), d(i,k,k-1)+d(k,j,k-1) )
    
    Predecessor Matrix:
        PI:n x n
        switch( PI[i,j] ):
          case i=j: NIL
          case no path from i to j: NIL
          else: predecessor of j in the sp (shortest path) from i  
    
    def Print_SP(PI,i,j):
        if i == j:
            Print'i''
            return
        if PI[i,j] == NIL:
            return
        Print_SP(PI,i,PI[i,j])
        Print''j''
        
    Base case like before k=0
    Inductive case: min( PI(i,j,k-1), PI(k,j,k-1) )

    FW(W,n){ #look up the rest online
        d(i,j,0) = W[i,j]
        PI(i,j,0) (like our base case)
        for k in 1...n:
            new matrices d(i,j,k) and PI(i,j,k)
            for i in 1...n:
                for j in 1...n:
                    if d(i,j,k-1

    
